// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel DepthCopy
#include "UnityCG.cginc"
#define THREADS 8

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


float sx;
float sy;
float dx;
float dy;
uint2 screenSize;
int sSlice;
int dSlice;

RWTexture2DArray<float> source;
Texture2D<float> _CameraDepthTexture;

[numthreads(THREADS, THREADS, 1)]
void DepthCopy(uint3 id : SV_DispatchThreadID) {
    if (id.x >= screenSize.x || id.y >= screenSize.y) {
        return;
    }
    source[uint3(id.xy, 0)] = 1 - _CameraDepthTexture[id.xy];
}

inline float SampleDepth(uint3 pos) {
    return source[uint3(min(pos.xy, float2(sx-1,sy-1)), pos.z)];
}

[numthreads(THREADS, THREADS, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float minValue = -1;
    float2 ratio = float2(screenSize.x / dx, screenSize.y / dy);
    uint3 prevId = uint3(id.xy << 1, sSlice);

    uint3 o1 = prevId + uint3(1, 0, 0);
    uint3 o2 = prevId + uint3(1, 1, 0);
    uint3 o3 = prevId + uint3(0, 1, 0);

    float d0 = source[prevId];
    float d1 = SampleDepth(o1);
    float d2 = SampleDepth(o2);
    float d3 = SampleDepth(o3);
    minValue = min(min(d0, d1), min(d2, d3));

    bool needExtraSampleX = ratio.x > 2;
    bool needExtraSampleY = ratio.y > 2;
    minValue = needExtraSampleX ? min(minValue, min(SampleDepth(prevId + uint3(2, 0, 0)), SampleDepth(prevId + uint3(2, 1, 0)))) : minValue;
    minValue = needExtraSampleY ? min(minValue, min(SampleDepth(prevId + uint3(0, 2, 0)), SampleDepth(prevId + uint3(1, 2, 0)))) : minValue;
    minValue = (needExtraSampleX && needExtraSampleY) ? min(minValue, SampleDepth(prevId + uint3(2, 2, 0)).x) : minValue;
    
    source[uint3(id.xy, dSlice)] = minValue;
}